// В данном примере (public class MessagingService) нарушение принципа OCP состоит в том, что при возникновении необходимости
// использовать другой тип коммуникации необходимо изменять код класса MessagingService.

public class MessagingService {
    public static void send(String deliveryType, String content) {
        if (deliveryType.equals("email")) {
            System.out.println("send email: " + content);
        } else {
            System.out.println("send sms: " + content);
        }
    }
}

//Во избежание нарушения OCP добавим интерфейс IMessagingService, реализуем его в классах
//для каждого типа сообщения о доставке, а также класс создадим класс MessagingFactory
//для реализации шаблона проектирования "Фабричный метод".

public interface IMessagingService {
    void send(String content);
}

public class EmailService implements IMessagingService {
    @Override
    public void send(String content) {
        System.out.println("send email: " + content);
    }
}

public class SmsService implements IMessagingService {
    @Override
    public void send(String content) {
        System.out.println("send sms: " + content);
    }
}

public class MessagingFactory {
    public IMessagingService initializeMessage(String deliveryType) {
        IMessagingService result = null;
        if (deliveryType.equals("email")) {
            result = new EmailService();
        } else if (deliveryType.equals("sms")) {
            result = new SmsService();
        }
        return result;
    }
}

//Для отправки сообщения применяется класс MessagingFactory,
//который возвращает соответствующий конкретный объект.
//Итого после рефакторинга исходный класс имеет вид:

public class MessagingService {
    public static void send(MessagingFactory messagingFactory, String deliveryType, String content) {
        IMessagingService messagingService = messagingFactory.initializeMessage(deliveryType);
        messagingService.send(content);
    }
}